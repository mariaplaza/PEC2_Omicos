---
title: '<center> <h1>Análisis de datos Ómicos (M0-157)</h1> </center>'
author: "María Plaza García"
subtitle: '`r params$subtitulo`'
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
citecolor: blue
urlcolor: blue
output:
  pdf_document: 
    df_print: kable
    fig_caption: yes
    highlight: tango
    keep_tex: yes
    latex_engine: lualatex
    number_sections: yes
    toc: yes
    toc_depth: 3
  html_document:
    df_print: paged
    toc: yes
    fig_caption: yes
    toc_float: true
    theme: united
    highlight: tango
  word_document:
    toc: true
link-citations: yes
nocite: |
  @love2015rna
  @love2014differential
  @robinson2010edger
  @chen2014edger
header-includes:
  - \usepackage[spanish]{babel}
  - \usepackage{subfig}
params:
  file1: counts.csv
  file2: targets.csv
  folder.data: ./datos
  subtitulo: Segunda prueba de evaluación continua
bibliography: PEC2.bib
geometry: margin=2cm
---

```{r setup, include=FALSE}
require(knitr)
knitr::opts_chunk$set(
  fig.show = "hold",
  fig.align='center',
  fig.height = 4.5,
  fig.width = 5,
	message = FALSE,
	warning = FALSE,
	cache = FALSE,
	comment = NULL,
	tidy = FALSE
)
options(width=90)
Sys.setlocale("LC_TIME", "C")
```

**Repositorio Github:**

https://github.com/mariaplaza/PEC2_Omicos

\pagebreak

# Abstract

Este documento presenta un análisis de datos de ultrasecuenciación mediante la realización de un estudio realizado con R y Bioconductor (paquetes EdgeR y DESeq2). El análisis se basará en los datos facilitados que proceden de un estudio obtenido del repositorio (GTEx) y del que hemos extraído una muestra aleatoria. A partir de dicho conjunto y de la información sobre el problema se han planteado los siguientes objetivos con el fin de determinar los genes diferencialmente expresados en los grupos a los que pertenecen las muestras. Se presenta una breve descripción del proceso general y los métodos utilizados en cada paso, así como los resultados obtenidos en cada fase del análisis. Finalmente se presenta una breve discusión sobre las posibles limitaciones encontradas y el código R empleado en el proceso.

# Objetivos

El objetivo principal de este trabajo ha sido emplear algunos de los metodos disponibles para el análisis en R de datos de RNA-seq en estudios de expresión génica diferencial con unos datos de contajes proporcionados. Para ello, se plantearon los siguientes objetivos específicos:
- Emplear los paquetes EdgeR y Deseq2 de Bioconductor disponibles en R.
- Puesto que hay tres grupos diferenciados, se realizan tres comparaciones: SFI-NIST, ELI-NIST y
ELI-SFI
- Análisis crítico de los resultados e identificación de las ventajas e inconvenientes encontrados.

# Materiales y Métodos
## Naturaleza de los datos

El archivo proporcionado `targets.csv` contiene la información de las muestras de un estudio obtenido del repositorio (GTEx1). Este repositorio contiene datos de múltiples tipos en un total de 54 tejidos. Nos centramos en los datos de expresión (RNA-seq) pertenecientes a un análisis del tiroides en donde se compara tres tipos de infiltración medido en un total de 292 muestras pertenecientes a tres grupos:

- Not infiltrated tissues (NIT): 236 muestras
- Small focal infiltrates (SFI): 42 muestras
- Extensive lymphoid infiltrates (ELI): 14 muestras

Los datos ya se encuentran preprocesados y emplearemos una selección aleatoria de 30 muestras, 10 de cada grupo.

Con la información de la muestras (subset) obtenidas, se han *subseteado* estas columnas con el archivo tambien proporcionado `counts.csv` que contiene una matriz de contaje que informa, para cada muestra, el número de fragmentos de secuencia que se han asignado a cada gen, de los diferentes genes de las muestras estudiadas, contenidas en `targets`.

## Procedimiento general de análisis (pipeline)

El pipeline da análisis de datos de RNA-seq es parecido al de microarrays salvo algunos pasos.
Se ha realizado siguiendo las pautas descritas en la guia de usuario desarrollada por @@chen2014edger y @love2019analyzing.
Básicamente los pasos seguidos son:

1. Lectura y preparación de los datos
2. Selección aleatoria de las muestras
3. Analisis preliminar de los datos
4. Agregar anotación genética
5. Filtrado para eliminar recuentos bajos
6. Normalización por sesgo de composición
7. Transformación de los datos, si es necesario
8. Estimación de dispersión
9. Análisis de expresión diferencial
   9.1 Identificación de genes diferencialmente expresados

El código siguiente se utilizó para instalar los paquetes de Bioconductor necesarios para el análisis:

```{r packages, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}

libraries <- c("htmltools", "bookdown", "bibtex" ,"knitr","dplyr", "printr", "Biobase", 
               "methods", "affy", "GEOquery", "simpleaffy", "arrayQualityMetrics",
               "biocLite", "pvca", "genefilter", "gcrma","plier", "mas5", "pheatmap",
               "RColorBrewer", "ggplot2")
check.libraries <- is.element(libraries, installed.packages()[, 1])==FALSE
libraries.to.install <- libraries[check.libraries]
if (length(libraries.to.install!=0)) {
  install.packages(libraries.to.install)
}

success <- sapply(libraries,require, quietly = FALSE,  character.only = TRUE)
if(length(success) != length(libraries)) {stop("A package failed to return 
                                               a success in require() function.")}

if(!require(DESeq2)) BiocManager::install("DESeq2")
if(!require(BiocManager)) install.packages("BiocManager")
if(!require(GenomicFeatures)) BiocManager::install("GenomicFeatures")
if(!require(DESeq2)) BiocManager::install("edgeR")
if(!require(pheatmap)) BiocManager::install("pheatmap")
if(!require(org.Hs.eg.db)) BiocManager::install("org.Hs.eg.db")
if(!require(genefilter)) BiocManager::install("genefilter")
if(!require(limma)) BiocManager::install("limma")

```

## Software empleado

Los análisis estadísticos se han realizado utilizando el lenguaje estadístico `R` y las dos librerías desarrolladas para el análisis de RNA-seq en el proyecto de Bioconductor (www.bioconductor.org). Se han empleado dos paquetes: `edgeR` [@robinson2010edger] y `DESeq2` [@love2014differential] para el análisis de los datos bajo el test Binomial Negativo, ya que ambos paquetes poseen un material estadístico potente, especialmente DESeq2. Su método de normalización es el denominado RPKM (Reads Per Kilobase of transcript and Million mapped reads). Así, la normalización previa en este paquete no es necesaria, lo cual es una ventaja. Aun asi, se ha empleado tambien el paquete edgeR para poder tener más referencias.

# Obtención y lectura de los datos

```{r datos1, include=FALSE}
library(readr)
library(knitr)
counts <- read_delim(file=file.path(params$folder.data,params$file1),";",
                      col_names = TRUE)

counts[] <- lapply(counts, function(x) { 
    if(is.factor(x)) as.numeric(as.character(x)) else x 
}) 
sapply(counts, class)

targets <- read_delim(file=file.path(params$folder.data,params$file2),",",
                      col_names = TRUE)
```

En primer lugar veamos ambos archivos de los que disponemos. La tabla de contajes (`counts`) y la tabla de muestras (`targets`) proporcionadas:

```{r echo=FALSE}
knitr::kable(head(counts, caption = "tabla de contajes")[,1:3])
knitr::kable(head(targets, caption = "tabla de las muestras")[,1:5])
```

El nombre de las filas en `counts` pertenece a las claves de tipo "ENSEMBL", conteniendo un punto y la versión de éste. Eliminamos la version y el punto para que posteriormente podamos emplear la AnnotationDBI para mapear mediante DESeq, si es necesario. Por otro lado, convertimos la matriz de caracteres a numéricos con el nombre de cada fila y columna, para poder trabajar con ellas. De esta forma nos quedan las siguientes tablas con las que vamos a trabajar y vemos las dimensiones de cada una de ellas para comprobar que están completas:

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(stringr)
counts[,1] = str_replace_all(counts$X1, "[.].{0,2}$", "")

conteos <- data.matrix(counts[,-1])

dimnames(conteos) <- counts[,1]
colnames(conteos) <- colnames(counts[,-1])

conteos.data.frame <- as.data.frame(conteos)

#length(complete.cases(conteos)) # comprobamos que el dataset está completo

targets <- read_delim(file=file.path(params$folder.data,params$file2),",",
                      col_names = TRUE)
#length(complete.cases(targets))

knitr::kable(head(conteos.data.frame, caption = "tabla de contajes")[,1:3])
knitr::kable(head(targets, caption = "tabla de las muestras")[,1:5])

```

Dimensión matriz de conteos:
```{r echo=FALSE}
dim(conteos.data.frame)
```

Dimensión matriz de las muestras:
```{r echo=FALSE}
dim(targets)
```

## Selección de las 30 muestras

Con el fin de obtener una selección de 30 muestras, 10 de cada tipo, de la tabla `targets` se ha creado el siguiente script. Como vemos, se ha incluido una semilla para que los mismos datos puedan ser reproducibles. Además se ha tenido en cuenta que existe una columna en la tabla que nos indica el tipo de muestra: "RNA Seq (NGS)" y "Allele-Specific Expression". Ya que solo nos interesan las muestras "RNA Seq (NGS)" en nuestro análisis, se ha incluido este filtro en la selección además del grupo. Sin ambargo, con este filtro el grupo *ELI* se quedaría solo con 8 muestras, por lo que no se ha incluido este filtro en este grupo, para que cada grupo tenga la misma proporción de muestras.

```{r message=FALSE, warning=FALSE, tidy=TRUE}

set.seed(12378)
n <- 10
library(dplyr)

#Grupo NIT
muestra_nit <- targets %>%
  filter(Group=="NIT" & molecular_data_type == "RNA Seq (NGS)") %>%
  sample_n(size=n,replace=FALSE)

#Grupo ELI
muestra_eli <- targets %>%
  filter(Group=="ELI") %>%
  sample_n(size=n,replace=FALSE)

#Grupo SFI
muestra_sfi <- targets %>%
  filter(Group=="SFI" & molecular_data_type == "RNA Seq (NGS)") %>%
  sample_n(size=n,replace=FALSE)

#Unir los grupos en un data frame
subset <- rbind(muestra_nit,muestra_eli, muestra_sfi)
knitr::kable(head(subset)[,1:5]) #primeras 6 filas del archivo
```

## Crear la matriz con las dimensiones del subset

Este paso es fundamental ya que es la tabla que vamos a emplear en nuestro análisis. Debemos ajustar la tabla counts proporcionada con las dimensiones y los datos de nuestra muestra escogida de forma aleatoria (subset). Esta nueva tabla se llama `counts.subset` y comprobamos que las dimensiones de la misma se corresponde con el número de filas de la tabla `counts` 56202 y el número de columnas de nuestra tabla de 30 muestras.

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
library(dplyr)
counts.subset<- dplyr::select(conteos.data.frame, contains(subset$Sample_Name))
dim(counts.subset)
```

# Análisis con el paquete edgeR

Ya que el paquete DESeq2 realiza la normalización de forma automática, separamos aqui el análisis de los dos paquetes.

## Preparación de los datos

Esta estapa incluye dos pasos muy importantes antes del análisis: filtrado de genes con baja o nula expresión y evaluación de la calidad de los datos.

Pero antes, creamos el objeto `DGEList` a partir de la matriz de conteos y la información de las muestras, es decir, cada uno de los tipos (ELI, NIT, SFI) incluidos en la columna `Group` y comprobamos que con el objeto de la clase `DGEList` se mantienen las dimensiones de la matriz:

```{r message=FALSE, warning=FALSE, tidy=TRUE}
# Creamos el objeto con la clase DGEList
library(edgeR)
dge <- DGEList(counts=counts.subset, group=subset$Group, genes = counts$X1)
dim(dge)
```

### Anotación

Nuestra tabla de resultados hasta ahora solo contiene las ID de genes de Ensembl, pero los nombres de genes alternativos pueden ser más informativos para la interpretación. Los paquetes de anotación de Bioconductor ayudan a mapear varios esquemas de identificación entre sí. Cargamos el paquete AnnotationDbi y el paquete de anotación org.Hs.eg.db. Este es el paquete de anotación de organismos ("org") para el Homo sapiens ("Hs"), organizado como un paquete de base de datos AnnotationDbi ("db"), utilizando ID de genes de Entrez ("eg") como clave principal.
Podemos usar la función mapIds para agregar columnas individuales a nuestra tabla de resultados. Proporcionamos los nombres de fila de nuestra tabla de resultados como una clave, y lo especificamos keytype=ENSEMBL.

Ahora los resultados tienen las ID de genes externas deseadas:

```{r echo=FALSE}
library("AnnotationDbi")
library("org.Hs.eg.db")
ens.str <- substr(rownames(dge), 1, 15)
dge$genes$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")

dge$genes$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

knitr::kable(head(dge$genes))
```

Sin embargo, aproximadamente la mitad de los genes se muestran como NA, por lo que entiendo que no se han reconocido como genes o la anotación no es la adecuada. Por ello, al final, no lo he utilizado en la interpretacion de los análisis.

### Filtrado y eliminación de genes con baja expresión

Generalmente, en las matrices de conteos hay un cierto número de genes que presentan pocas o ninguna lectura en todas o la mayoría de las muestras, como ocurre en nuestro caso. Estos genes, pueden no ser de interés puesto que el objetivo de los estudios de expresión génica diferencial es determinar aquellos genes cuyo nivel de expresión es significativamente diferente entre los distintos grupos a comparar. Por supuesto, este paso es subjetivo, ya que algunos investigadores creen que no se deben eliminar datos ya que el echo de que se presenten pocas lecturas en también un importante dato. Sin embargo, ya que el número de genes es muy elevado, he procedido al filtrado de los genes que no mostraban un nivel de expresión significativo, con el fin de mejorar la visibilidad y la interpretación de los resultados.

Para ello, en primer lugar se realizó una transformación de los datos con el fin de tener en una misma escala todas las muestras y evitar, así, diferencias debido al distinto tamaño de las librerías. La transformación que se llevó a cabo fue la conversión de las lecturas a CPM (conteos por millón). En este caso, ya que los grupos son pequeños, no más de diez muestras cada grupo, se mantendrán los genes que logran al menos 0.01 cpm de tres. Vemos la nueva dimensión de nuestra matriz de trabajo:

```{r message=FALSE, warning=FALSE, tidy=TRUE}
# Paso de los datos a CPM conteos por millón, con la función cpm del paquete edgeR.
library(edgeR)
select.genes <- rowSums(cpm(dge)>0.01) >= 3
dge <- dge[select.genes,] # Nuevo objeto de estudio, ya filtrado.
dim(dge)
```

Al imponer la condición de *cpm(y) > 3*, se crea una matriz con valores lógicos donde aparecerá TRUE si la condición se cumple y FALSE si no se cumple. Tras hacer esto, sólo nos quedamos con las filas, es decir, los genes, en los que haya más de tres coincidencias con TRUE. Los genes seleccionados están en el vector `select.genes`, y con éste se puede eliminar los que no hayan sido seleccionados del objeto que estamos estudiando.

Se ha disminuido considerablemente el número de genes para analizar, exactamente nos quedan 39971 genes de los 56202 originales, por lo que el análisis y por tanto los resultados y las interpretaciones serán más claras. La matriz de conteos seguirá estando en condiciones para proceder al análisis, sin embargo, el tamaño de las muestras calculadas anteriormente no se ha modificado con este cambio, y se necesita los valores reales. Vemos aqui el tamano de las librerias antes y después del filtrado:

Antes:
```{r echo=FALSE}
dge$samples$lib.size # Tamaño de librería antes del filtrado
```

Después del filtrado:
```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
dge$samples$lib.size <- colSums(dge$counts)
dge$samples$lib.size # Nuevo tamaño de la librería
```

### Normalización

Durante la preparación de la muestra o el proceso de secuenciación, los factores externos que no son de interés biológico pueden afectar la expresión de muestras individuales. Por ejemplo, las muestras procesadas en el primer lote de un experimento pueden tener una mayor expresión general en comparación con las muestras procesadas en un segundo lote. Se supone que todas las muestras deben tener un rango y distribución de valores de expresión similares. Se requiere, por tanto, la normalización para garantizar que las distribuciones de expresión de cada muestra sean similares en todo el experimento.

Cualquier gráfico que muestre las distribuciones de expresión por muestra, como una densidad o un diagrama de cajas, es útil para determinar si alguna muestra es diferente de otras y si es por tanto necesaria la normalización. A continuación, utilizaremos diagramas de cajas para verificar la distribución de los recuentos de lectura en la escala `log2`. Podemos usar la función `cpm` para obtener recuentos de log2 por millón, que se corrigen para los diferentes tamaños de biblioteca. Esta función también agrega un pequeño desplazamiento para evitar tomar el registro de cero:

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Boxplot de logCPMs de muestras normalizadas'}
# log2 conteos por millón
logcounts <- cpm(dge,log=TRUE)
# boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=1, cex.axis = 0.6)
# Anadimos una linea azul que se corresponde con la media logCPM
abline(h=median(logcounts),col="blue")
```

De los diagramas de caja vemos que, en general, las distribuciones de densidad de las intensidades logarítmicas en bruto no son idénticas pero tampoco muy diferentes. Si una muestra está realmente muy por encima o por debajo de la línea horizontal azul, es posible que necesitemos investigar más a fondo esa muestra. Conveniente normalizar pero no parece que hayan muestras problemáticas.

Por otro lado, en general, se considera que la normalización de TMM o método de la media recortada [@robinson2010scaling] es satisfactoria para casi todos los experimentos de expresión de genes de ARNm bien diseñados. Por lo que la vamos a realizar en nuestro caso.

La normalización por el método TMM se realiza utilizando la función `calcNormFactors` en edgeR. Los factores de normalización calculados se utilizan como un factor de escala para los tamaños de la librería. Cuando se trabaja con objetos DGEList, estos factores de normalización se almacenan automáticamente `x$samples$norm.factors`. Para nuestro conjunto de datos, el efecto de la normalización de TMM es leve, como es evidente en la magnitud de los factores de escala, que están relativamente cerca de 1.

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
dge.norm <- calcNormFactors(dge)
knitr::kable(head(dge.norm$samples))
```

Tras hacer la normalización la columna donde aparece los factores de normalización cambia, ya que antes estaban los valores por defecto que le asignaba la función DGEList.
Veamos el diagrama de caja de los datos normalizados:

```{r echo=FALSE, fig.cap='Boxplot de logCPMs de muestras normalizadas', fig.show = "hold"}
# log2 conteos por millón
logcounts1 <- cpm(dge.norm,log=TRUE)
# boxplots
boxplot(logcounts1, xlab="", ylab="Log2 counts per million",las=1, cex.axis = 0.6)
# Linea azul con la media logCPM
abline(h=median(logcounts1),col="blue")
```

## Exploración de los datos

El gráfico MDS (Multidimensional scaling plot of distances) muestra la relación entre todas las muestras. El análisis que realiza este gráfico es similar a un PCA, es decir, al análisis de componentes principales. Es una herramienta increíblemente útil para el control de calidad y la comprobación de valores atípicos [Figura 3].

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Gráfico MDS que muestra la relación entre los distintos tipos de infiltración', fig.show = "hold", fig.height=4, fig.width=4}
grupo <- as.factor(as.character(subset$Group))
col.status <- c("blue","red","dark green")[grupo]
plotMDS(dge.norm$counts, labels = grupo, col=col.status)
legend("bottomright",fill=c("blue","red","dark green"),legend=levels(grupo))
```

Dicha figura muestra que las diferencias entre los grupos no son mucho mayores que las diferencias dentro de los grupos, lo que significa que **puede que no haya diferencias estadísticamente significativas entre los grupos**. La distancia entre los tipos a la izquierda y la derecha es además muy elevada, lo que implica una importante diferencia entre las muestras. Por otro lado, estas dos muestras situadas a la izquierda de los grupos NIT y ELI se encuentran muy separadas del resto, lo que quizá indique anomalías en las muestras, y habría que considerar su eliminación del análisis.

Los perfiles de expresión de muestras individuales se pueden explorar más de cerca con gráficos de diferencia de medias (MD). Un diagrama de MD visualiza size-adjusted log-fold change por tamaño de librería entre dos librerías (la diferencia) frente a la expresión de registro promedio en esas librerías (la media). Veamos un diagrama MD que compara la muestra 1 con una librería de referencia artificial construida a partir del promedio de todas las otras muestras [Figura 4].

```{r echo=FALSE, fig.show = "hold", fig.height=4, fig.width=4, fig.cap='Gráfico MD de la muestra situada en primer lugar'}

plotMD(dge.norm, column=1)
abline(h=0, col="red", lty=2, lwd=2)
```

La mayor parte de los genes se centran alrededor de la línea de log-fold change cero. Las líneas diagonales en la esquina inferior izquierda de la gráfica corresponden a genes con recuentos de 0, 1, 2, etc. en la primera muestra.

Es una buena práctica hacer gráficos MD para todas las muestras como un control de calidad, siempre que no sean demasiadas. Vemos como se distribuyen nuestras muestras en la [Figura 5]:

```{r echo=FALSE, fig.cap='Gráfico MD de las 30 muestras', fig.height=7, fig.width= 7, message=FALSE, warning=FALSE, tidy=TRUE, fig.show = "hold"}
par(mar=c(1,1,1,1))
par(mfrow=c(6,5))
# Create the loop.vector (all the columns)
loop.vector <- 1:30

for (i in loop.vector) { # Loop over loop.vector

    # Plot histogram of x
  plotMD(dge.norm, column=i)
  abline(h=0, col="red", lty=2, lwd=2)
}
```

Por ejemplo, en la muestra GTEX-R55G-0726-SM-2TC6J las proporciones logarítmicas muestran un sesgo positivo notable, con una serie de genes muy altamente regulados (por encima de la linea roja), en comparación con otras muestras. Estos genes explican por qué el factor de normalización para esta muestra está muy por debajo de uno. Por el contrario, las proporciones logarítmicas para la muestra 1 estaban algo sesgadas negativamente, lo que corresponde a un factor de normalización superior a uno.

También podemos explorar las relaciones entre las muestras visualizando un heatmap de la matriz de correlación. El resultado de este gráfico corresponde a lo que sabemos sobre el conjunto de datos. Primero, las muestras provienen de individuos diferentes, por lo que los tres grupos son muy diferentes [Figura 6].

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Heatmap de la matriz de correlación entre las distintas muestras', fig.show = "hold", fig.height=6, fig.width=6}

library(RColorBrewer)
cimColor <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)[255:1]
heatmap(cor(logcounts1), col=cimColor)
```

## Estimación de la dispersión

El paquete `edgeR` usa la distribución binomial negativa (NB) para modelar los recuentos de lectura para cada gen en cada muestra. El parámetro de dispersión de la distribución NB explica la variabilidad entre repeticiones biológicas [@mccarthy2012differential]. El primer paso del análisis consiste en estimar la dispersión de cada transcrito a partir de la variabilidad total para todos los genes. El método que emplea `edgeR` para el cálculo de la dispersión común en el caso de experimentos que se ajusten al enfoque clásico de `edgeR` (comparaciones por pares entre grupos, experimentos de un solo factor) es el método qCML (de las siglas en inglés quantile-adjusted Conditional Maximum Likelihood). El estimador qCML, comparado con otros estimadores (estimador de máxima verosimilitud, el estimador de cuasi-verosimilitud, etc), es el que mejor funciona con datos de secuenciación de NGS y el más fiable cuando se trabaja con un número bajo de muestras.

A partir del objeto *DGEList* normalizado, se procedió a la estimación en un único paso de la dispersión común, o variabilidad total, y la dispersión gen a gen o tagwise empleando, para ello, la función `estimateDisp()`: 

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}

disp <- estimateCommonDisp(dge.norm,verbose=TRUE)
disp.all <- estimateDisp(dge.norm, robust=TRUE)

# Al calcular la dispersión común añadiremos como atributo en la función 
# verbose = TRUE para que muestre los valores del coeficiente de variación 
# biológico (BCV) y la dispersión común.
 
disp.estim <- estimateTagwiseDisp(disp)
```

Tal y como se puede ver en la salida obtenida al estimar la dispersión común, ésta es de 0.277, no muy elevada, y el coeficiente de variación biológica (BCV) de un 53 %. La variación biológica entre las muestras de un mismo grupo es un factor que influye considerablemente en el número de genes DE (diferencialmente expresados).
Cuanto mayor sea la variación entre grupos con respecto a la variación intragrupo más fácil es la detección de estos genes.

Estas dispersiones las representamos con un gráfico BCV [Figura 7], y así podemos comprobar si la dispersión común representa realmente la dispersión existente entre los genes.

```{r echo=FALSE, fig.height=4.5, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Gráfico BCV que muestra la dispersion entre los dstintos genes'}
plotBCV(disp.all)
```

El eje vertical de la gráfica BCV muestra la dispersión de la raíz cuadrada, también conocida como coeficiente de variación biológica (BCV). Para los estudios de RNA-seq, las dispersiones de NB tienden a ser mayores para los genes con recuentos muy bajos. Cada punto del gráfico representa un gen. La línea azul refleja la tendencia de la variación biológica a medida que aumenta el número de lecturas. En nuestro caso, la tendencia de dispersión tiende a disminuir suavemente con la abundancia y de forma asintótica a un valor constante para genes con recuentos más grandes.

Generalmente, se considera óptimo para la detección de genes DE cuando el valor común del coeficiente de variación biológico se encuentra entre 0.2 y 0.4.  Como vemos, la línea roja sobrepasa el umbral de 0,4 lo que podría afectar al número de genes DE que se encuentren (seleccionándose menos de los que realmente hay).

El modelo NB puede ampliarse con métodos de cuasi-verosimilitud (QL) para tener en cuenta la variabilidad específica de genes de fuentes biológicas y técnicas. Bajo el marco de QL, la tendencia de dispersión de NB se usa para describir la variabilidad biológica general en todos los genes, y la dispersión de QL recoge la variabilidad específica del gen por encima y por debajo del nivel general. En el enfoque QL, no se usan las dispersiones NB individuales (por etiqueta). La estimación de las dispersiones QL se realiza utilizando la  función `glmQLFit`, que nos devuelve un objeto con los valores estimados de los coeficientes GLM para cada gen. También contiene una serie de estadísticas empíricas de Bayes (EB) que incluyen la tendencia de dispersión QL, las estimaciones de dispersión QL exprimidas y los grados de libertad anteriores (df) [Figura 8].

```{r echo=FALSE}
fit <- glmQLFit(disp.all, robust=TRUE)
knitr::kable(head(fit$coefficients))
```

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE, fig.width=4, fig.height=4, fig.cap='Gráfico de la dispersión cuasi-verosimilitud de genes respecto la media log2 en cpm', fig.show = "hold"}
plotQLDisp(fit)
summary(fit$df.prior)
```

Obtenemos unas estimaciones de df bajas, lo que indican que las dispersiones son muy variables.

Una vez calculados los factores de normalización y las estimación de las dispersiones, vamos a realizar las pruebas para determinar la expresión diferencial y buscar diferencias entre los tres grupos. La función que realiza estas pruebas es `exactTest()`.

## Análisis de expresión diferencial
### Comparación entre los grupos ELI y NIT

Vamos a realizar para ello pruebas de razón de probabilidad para nuestros tejidos y observar las diferencias del grupo ELI *vs* NIT. La función `exactTest()` lleva a cabo pruebas usando la binomial negativa exacta. 

La función `topTags()` muestra convenientemente los resultados de las pruebas para las n etiquetas más significativas, es decir, los transcritos más diferencialmente expresados y las razones de falsos descubrimientos (FDRs). Ordenamos la tabla según la columna `PValue`.

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
et <- exactTest(disp.estim, pair = c("ELI","NIT"))
top <- topTags(et, n=39971)
head(top)[1:6,-1]
```

La columna `logFC` proporciona la diferencia log-fold change para los recuentos entre los dos grupos. Al estar ordenados según la columna *P-Value*, los primeros elementos serán los que menor p-valor tengan, que coincide, lógicamente, con los menores FDRs, y se ve que existen genes que tienen estos dos datos muy bajos, lo que indica que es más probable que estos genes sean biológicamente significativos.

La siguiente tabla muestra los recuentos sin procesar de los genes que edgeR ha identificado como los más expresados diferencialmente. Para estos genes parece haber diferencias aunque no muy grandes entre los grupos, lo que sugiere que los genes DE identificados puede que no se expresan de manera realmente diferencial y pueden ser falsos positivos.

```{r echo=FALSE}
detags.com <- rownames(topTags(et)$table)
disp$counts[detags.com, 1:4]
```

Veamos ahora el número y porcentaje de genes que se consideran diferencialmente expresados, según posean un FDR menor a 0.5:

```{r echo=FALSE}
table(top$table$FDR <0.5)
table(top$table$FDR <0.05)/nrow(top$table)
```

Solamente se han muestrado diez genes de los 39971 genes estudiados, en general, será más fácil observar la proporción de DGEs através de gráficos.

```{r echo=FALSE, fig.height=3.5, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Histograma FDR (ELI vs. NIT)', fig.show = "hold"}

hist(top$table$FDR, breaks=100, xlab="FDR", main="")
abline(v=0.05, col="red", lwd=3)
```

Se ha establecido el corte en \alpha = 0.05 para identificar los genes que están diferencialmente expresados. Un 85.1 % de los genes no se pueden considerar que tengan expresiones distintas en los diferentes grupos, además en el histograma se ve que la mayoría de los datos los encontramos tras el \alpha = 0.05.

La funcion `decideTestDGE()` muestra la clasificación de los genes como no significativos, sobreexpresados o infraexpresados dependiendo del nivel de significación establecido, en este caso en FDR <0.05:

```{r echo=FALSE}
de <- decideTestsDGE(et)
summary(de)
```

La mayoria de los genes se muestran como no significativos. El número total de genes con un valor de FDR inferior al nivel de significación (\alpha = 0,05) fue de 5975 De estos genes, 2042 se identificaron como sobrerregulados y 3933 como infrarregulados.

Para visualizar gráficamente los genes identificados como DE respecto a la totalidad, se emplea el gráfico obtenido con la función `plotSmear` [Figura 10] que muestra los cambios log-fold-tagwise contra log-cpm (análogo a un gráfico MA para datos de microarrays). Los genes diferencialmente expresados se muestran resaltados en rojo.
```{r echo=FALSE, fig.show = "hold", fig.height=4, fig.width=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='plotSmear NIT vs. ELI'}
detags <- rownames(dge)[as.logical(de)]
plotSmear(et, de.tags=detags)
abline(h=c(-1,1), col="blue")
```
\pagebreak

### Comparación entre los grupos SFI y NIT

Realizamos los mismos pasos anteriores, pero comparando en este caso los grupos NIT y SFI, indicación que incluimos dentro de la función `exactTest` con el comando `pair`.

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
et.1 <- exactTest(disp.estim, pair = c("NIT", "SFI"))
top.1 <- topTags(et.1, n=39971)
head(top.1)[,-1]
```

En este caso, los genes tienen los P-value bajos, pero no demasiado, lo que indica que es menos probable que estos genes sean biológicamente significativos.

Veamos ahora el número y porcentaje de genes que se consideran diferencialmente expresados, según posean un FDR menor a 0.5:

```{r echo=FALSE}
table(top.1$table$FDR <0.5)
table(top.1$table$FDR <0.05)/nrow(top.1$table)
```

El análisis de la proporción de DGEs se observa en el siguiente histograma:

```{r echo=FALSE, fig.height=3.5, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Histograma FDR (SFI vs. NIT)', fig.show = "hold"}

hist(top.1$table$FDR, breaks=100, xlab="FDR", main="")
abline(v=0.05, col="red", lwd=3)
```

Se ha establecido de nuevo el corte en \alpha = 0.05 para identificar los genes que están diferencialmente expresados. Un 99.4% de los genes no se pueden considerar que tengan expresiones distintas en los diferentes grupos, además en el histograma se ve que la mayoría de los datos los encontramos tras el \alpha = 0.05 y casi todos con valores elevados alrededor de 1.

Se muestra ahora la salida de la función `decideTestDGE()` con la clasificación de los genes como no significativos, sobreexpresados o infraexpresados con un FDR <0.05:

```{r echo=FALSE}
de.1 <- decideTestsDGE(et.1)
summary(de.1)
```

El número total de genes con un valor de FDR inferior al nivel de significación (α = 0,05) fue de 39743, casi todos los incluidos en el estudio tras realizar el filtro. De estos genes, 7 se identificaron como infrarregulados y 221 como sobrerregulados.

Veamos ahora el gráfico `plotSmear` [Figura 12] que muestra los cambios log-fold-tagwise contra log-cpm donde los genes diferencialmente expresados se muestran resaltados en rojo, que como vemos el número es muy bajo.
```{r echo=FALSE, fig.height=4, fig.width=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='plotSmear SFI vs. NIT', fig.show = "hold"}
detags.1 <- rownames(dge)[as.logical(de.1)]
plotSmear(et.1, de.tags=detags.1)
abline(h=c(-1,1), col="blue")
```
\pagebreak

### Comparación entre los grupos SFI y ELI

Realizamos los mismos pasos anteriores, pero comparando en este caso los grupos ELI y SFI, indicación que incluimos dentro de la función `exactTest` con el comando `pair`.

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
et.2 <- exactTest(disp.estim, pair = c("ELI", "SFI"))
top.2 <- topTags(et.2, n=39971)
head(top.2)[,-1]
```

En este caso, los genes tienen los P-value bajos, lo que indica que es probable que estos genes sean biológicamente significativos.

El número y porcentaje de genes que se consideran diferencialmente expresados, según posean un FDR menor a 0.5 son los siguientes:

```{r echo=FALSE}
knitr::kable(table(top.2$table$FDR <0.5))
knitr::kable(table(top.2$table$FDR <0.05)/nrow(top.2$table))
```

El siguiente histograma muestra el análisis de la proporción de DGEs en esta compración:
```{r echo=FALSE, fig.height=3.5, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Histograma FDR (SFI vs. ELI)',fig.show = "hold"}

hist(top.2$table$FDR, breaks=100, xlab="FDR", main="")
abline(v=0.05, col="red", lwd=3)
```

Se ha establecido de nuevo el corte en \alpha = 0.05 para identificar los genes que están diferencialmente expresados. Un 86% de los genes no se pueden considerar que tengan expresiones distintas en los diferentes grupos, además en el histograma se ve que la mayoría de los datos los encontramos tras el \alpha = 0.05.

Se muestra ahora la salida de la función `decideTestDGE()` con la clasificación de los genes como no significativos, sobreexpresados o infraexpresados con un FDR <0.05:

```{r echo=FALSE}
de.2 <- decideTestsDGE(et.2)
summary(de.2)
```

El número total de genes con un valor de FDR inferior al nivel de significación (\alpha = 0,05) fue de 6515. De estos genes, 3333 se identificaron como infrarregulados y 2282 como sobrerregulados.

El gráfico `plotSmear` que muestra los cambios log-fold-tagwise contra log-cpm donde los genes diferencialmente expresados se muestran resaltados en rojo en la Figura 14. En este caso un hay buen número, al igual que con la primera comparacion entre los grupos NIT y ELI [Figura 14].
```{r echo=FALSE, fig.show = "hold", fig.height=4, fig.width=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='plotSmear SFI vs. ELI'}
detags.2 <- rownames(dge)[as.logical(de.2)]
plotSmear(et.2, de.tags=detags.2)
abline(h=c(-1,1), col="blue")
```
\pagebreak

# Análisis con DESeq2
## DESeq Dataset

Empleamos ahora el paquete `DESeq2`. El modelo probabilístico que utiliza este paquete es, al igual que `EdgeR`, la Binomial Negativa. Sin embargo, cada uno emplea su propia estrategia de normalización.

El análisis de expresión diferencial con `DESeq2` es todavía más cómodo y sencillo ya que no es necesario realizar los diferentes pasos del análisis uno a uno. La mayoría de las funciones se han unificado y, una vez creado el objeto de la clase `DESeq-DataSet` con los datos de conteos y con la correspondiente información sobre las muestras, realiza todo el análisis a través de la función `DESeq()`. Finalizado el análisis, es posible visualizar los resultados a través de la función `results()`.

En primer lugar, se ha creado el objeto de clase `DESeqDataSet`, representado mediante el objeto *dds*, para almacenar el data frame que contiene la matriz de conteos y las condiciones del estudio (condition) de los diferentes grupos de las muestras estudiadas. Para ello, se ha usado la función `DESeqDataSetFromMatrix`, ya que partimos de una matriz ya procesada. Posteriormente, la función `DESeq` recoge los datos, estimando los factores de tamaño y de dispersión, para cada gen y la adaptación a un modelo lineal generalizado:

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
library(DESeq2) # creamos el objeto DESEQDataSet

condition <- factor(subset$Group)
coldata <- data.frame(row.names=colnames(counts.subset), condition)

dds <- DESeqDataSetFromMatrix(countData=counts.subset, 
                              colData=coldata, 
                              design=~condition)
dds
```

Ahora estamos listos para ejecutar la función `DESEQ`:

```{r message=FALSE, warning=FALSE, tidy=TRUE}
dds.1 <- DESeq(dds) # Run the DESeq pipeline
dds.1
```

Podemos representar esta función con el siguiente gráfico [Figura 15], que indica la media de los conteos normalizados de cada gen frente a su dispersión por gen y a la dispersión común o curva ajustada a la dispersión de cada gen, estando la primera representada con puntos negros y la segunda con la línea roja.
```{r echo=FALSE, fig.show = "hold", fig.height=4, fig.width=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Gráfico de las estimaciones de dispersión por gen junto con la relación media de dispersión ajustada'}
# Plot dispersions
#png("qc-dispersions.png", 1000, 1000, pointsize=20)
plotDispEsts(dds.1)
```

Este gráfico puede ser un diagnóstico útil. Algunas estimaciones genéticas se marcan como valores atípicos y no se reducen hacia el valor ajustado (fitted). Si se observa el eje Y, vemos que cuando aumentan los conteos normalizados disminuye la dispersión. Los puntos por debajo de la línea roja pueden deberse al bajo número de réplicas de las muestras o individuos estudiados, por eso, la funcion `DESeq`, que toma un enfoque conservador y le asigna a los genes que quedan por debajo de la curva el valor ajustado y le asigna a cada gen la dispersión máxima posible.

## Análisis exploratorio y visualización
### Filtrado de datos

Al igual que con el paquete `edgeR` reducimos el tamaño del objeto y aumentamos la velocidad de nuestras funciones. Eliminamos por tanto las filas que no tienen o casi no tienen información sobre la cantidad de expresión génica. Para algunos conjuntos de datos, puede tener sentido realizar un filtrado adicional. Por ejemplo, se puede especificar que al menos 3 muestras tengan un conteo de 10 o más. Una recomendación para el número de muestras se establecería en el tamaño de grupo más pequeño. Dicha regla podría especificarse creando un vector lógico y sub-conjustando el ddsl anterior:

```{r eval=FALSE, include=TRUE}
keep1 <- rowSums(counts(dds.1) >= 5) >= 2
dds.3 <- dds.1[keep1,]
nrow(dds.3)
```

Sin embargo, aquí aplicamos la regla de filtrado más mínima: eliminando filas del `DESeqDataSet` que no tienen recuentos o menos dos recuentos en todas las muestras:

```{r}
keep <- rowSums(counts(dds.1)) > 2
dds.2 <- dds.1[keep,]
nrow(dds.2)
```

### Transformación de los datos para su visualización

Aunque en el paquete `DESeq2` se opera con conteos, utilizando distribuciones discretas, para la realización de otros análisis como pueden ser la visualización o el agrupamiento, es útil trabajar con versiones transformadas de los datos de conteo. Debido a esto, se ha realizado una transformación logarítmica regularizada (rlog) y la hemos comparado con la transformación que nos da la función `vst` (mucho más rápida) que emplea una transformación estabilizadora de varianza.

Para los genes con recuentos altos, el rlog dará un resultado similar a la transformación log2 ordinaria de los recuentos normalizados. Para los genes con recuentos más bajos, los valores se reducen a los promedios de los genes en todas las muestras. Los datos transformados por rlog se vuelven aproximadamente homoscedásticos. Podemos ver estos datos transformados en los siguiente histogramas:

```{r echo=FALSE, fig.height=3.5, fig.width=6, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Histogramas que representan los datos transformados de forma logarítmica (rlog) respecto a una transformación segun la varianza', fig.show = "hold"}
# Regularized log transformation
rld <- rlogTransformation(dds.2)
par(mfrow=c(1,2))
hist(assay(rld), main = "Hist transf con rlog")

vsdata <- vst(dds.2, blind=FALSE)
hist(assay(vsdata), main = "Hist transf con vst")
```

Se muestran ahora diagramas de dispersión con los recuentos sin normalizar (izquierda), utilizando el rlog (centro) y la transformación vsd (derecha). Como vemos `vsd` tiene un desplazamiento hacia arriba para los valores más pequeños. Son las diferencias entre las muestras (desviación de y = x en estos diagramas de dispersión) lo que contribuirá a los cálculos de distancia y al diagrama de PCA.

```{r echo=FALSE, fig.height=3, fig.width=4.5, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Efecto visual de amabas transformaciones, rlog y vst'}
par(mfrow=c(1,3))
plot(assay(dds.2))
plot(assay(rld))
plot(assay(vsdata))
```

Podemos ver cómo los genes con recuentos bajos, es decir, que aportan poca información sobre su expresión diferencial (esquina inferior izquierda) comprimen sus diferencias con rlog.

### Distancia entre las muestras

De forma complementaria al estudio de los datos, se ha podido realizar un análisis que indique si existe alguna relación entre las muestras, es decir, si hay algunas similitudes entre ellas, mediante un análisis de distancias, usando la función `dist`.

Para ello realizamos el siguiente *heatmap* donde se pueden observar los genes diferencialmente expresados, y así conseguir una información muy visual que puede ayudar a extraer el sentido biológico junto a los datos que obtendremos posteriormente. De este modo, se puede observar qué genes están más sobreexpresados en las diferentes condiciones, agrupadas de manera jerárquica en el dendograma [Figura 18]. Usamos en este caso la transformación vsd y seleccionamos los 10 genes con la mayor varianza entre las muestras.
```{r echo=FALSE, fig.align='center', fig.show = "hold", fig.height=6, fig.width=8, message=FALSE, fig.cap='Heatmap que representa las distancias entre 10 genes con la mayor varianza'}

library(pheatmap)
topVarGenes <- head(order(rowVars(assay(vsdata)), decreasing = TRUE), 10)

mat  <- assay(vsdata)[topVarGenes, ]
mat  <- mat - rowMeans(mat)
anno <- as.data.frame(colData(vsdata)[, c("condition", "sizeFactor")])
pheatmap(mat, annotation_col = anno)
```
\pagebreak

### Análisis de componentes principales

De forma complementaria al análisis de agrupamientos, se ha analizado también la similitud entre muestras mediante el análisis de componentes principales (PCA). En esta gráfica, las muestras se proyectan de manera que se extienden en dos direcciones que explican la mayoría de las diferencias entre ellas. El eje x es la dirección que más separa los puntos de datos, el eje y es una dirección ortogonal a la primera, que es la segunda que más separa los datos. El porcentaje de la varianza total que está contenida en la dirección se puede ver en la etiqueta del eje.

Los grupos aparecen algo separados pero el porcentaje de variabilidad explicado por las dos primeras componentes sugiere que pueden ser muy explicativas.

Vemos que hay una leve separación entre los tres grupos. NIT está claramente condicionado a la izquierda, y ELI a la derecha. Sin embargo, hay una muestra del grupo ELI que se encuentra muy distanciada del resto de muestras de su grupo. El grupo SFI está distribuido de forma desigual en todo el gráfico.

Podemos detectar cuáles son las muestras que se encuentran  estrañamente distribuidas si incluimos los nombres de las muestras en el gráfico [Figura 19].
```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Análisis de componentes principales entre las muestras transformadas de forma logarítmica', fig.show = "hold"}
library(RColorBrewer)
mycols <- brewer.pal(8, "Dark2")[1:length(unique(condition))]

rld_pca <- function (rld, intgroup = "condition", ntop = 500, colors=NULL, 
                     legendpos="bottomleft", main="PCA Biplot", textcx=0.55, ...) {
  require(genefilter)
  require(calibrate)
  library(calibrate)
  require(RColorBrewer)
  rv = rowVars(assay(rld))
  select = order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca = prcomp(t(assay(rld)[select, ]))
  fac = factor(apply(as.data.frame(colData(rld)[, intgroup, drop = FALSE]), 1, paste, 
                     collapse = " : "))
  if (is.null(colors)) {
    if (nlevels(fac) >= 3) {
      colors = brewer.pal(nlevels(fac), "Paired")
    }   else {
      colors = c("black", "red")
    }
  }
  pc1var <- round(summary(pca)$importance[2,1]*100, digits=1)
  pc2var <- round(summary(pca)$importance[2,2]*100, digits=1)
  pc1lab <- paste0("PC1 (",as.character(pc1var),"%)")
  pc2lab <- paste0("PC1 (",as.character(pc2var),"%)")
  plot(PC2~PC1, data=as.data.frame(pca$x), bg=colors[fac], pch=21, xlab=pc1lab, ylab=pc2lab, main=main, ...)
  with(as.data.frame(pca$x), textxy(PC1, PC2, labs=rownames(as.data.frame(pca$x)), 
                                    cex=textcx))
  legend(legendpos, legend=levels(fac), col=colors, pch=20)
}
#png("qc-pca.png", 1000, 1000, pointsize=20)
rld_pca(rld, colors=mycols, intgroup="condition", xlim=c(-50, 75))
```
\pagebreak

### PlotCounts

También puede ser útil examinar los recuentos de lecturas de un solo gen en todos los grupos. Una función simple para hacer este gráfico es `plotCounts`, que normaliza los recuentos mediante la secuencia de profundidad y agrega un pseudocuenta de 1/2 para permitir el trazado de la escala logarítmica. Los recuentos se agrupan por las variables en `intgroup`, donde se puede especificar más de una variable. Aquí especificamos los genes que tenía el valor p más pequeño de la tabla de resultados creada anteriormente y observamos los valores en los distintos grupos.
```{r echo=FALSE, fig.show = "hold", message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Plotcounts para comparar los los conteos normalizados entre los tres grupos para los 6 primeros genes'}

par(mfrow=c(2,3))
plotCounts(dds.2, gene="ENSG00000168615", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000110680", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000236935", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000226423", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000177721", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000264940", intgroup="condition")
```
\pagebreak

## Análisis de expresión diferencial

Para comparar los tres grupos por parejas, se ha utilizado la función `results`, a la que se le ha añadido un contraste (por ejemplo, contrast = c("condition", "ELI", "SIF")) para seleccionar las muestras que queremos comparar. Así, se realizaron tres comparativas: ELI *vs* SFI, SFI *vs* NIT y NIT *vs* ELI.

Mediante esta función, se calcula el `log2FoldChange`, que es la estimación del efecto. Indica cuánto cambia la expresión del gen de una muestra respecto a la otra. Además, se realiza para cada gen una prueba de hipótesis para ver si existe una variabilidad experimental, con el p-valor. Posterior a la visualización de los resultados, se han ajustado los datos al estudio, estableciendo un ajuste del p-valor (padj) menor a 0.05. Este p-valor se obtiene mediante el método de Benjamini-Hochberg, indicando el false discovery rate (FDR).

### ELI *vs* NIT

Para identificar los genes más diferencialmente expresados(genes DE), echamos un vistazo a la tabla de resultados. Como la variable *dds* contiene diferentes comparaciones, es necesario extraer la comparación de interés para proceder con las comparaciones entre los tres grupos.

Hay dos formas de ser estrictos acerca de qué conjunto de genes se consideran significativos:

\begin{enumerate}
   \item baja el umbral de tasa de descubrimiento falso (\textit {padj})
   \item eleva el umbral de cambio de plegado log2 de 0 utilizando el argumento de resultados \textit {lfcThreshold}.
\end {enumerate}

Para conocer el número de genes que se expresaban diferencialmente entre los grupos experimentales, se recurre a la función `summary()`. Fijamos el umbral de la tasa de descubrimiento falso a un \alpha = 0.05, al igual que en el caso anterior:

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}

res1 <- results(dds.2, contrast=c("condition","ELI","NIT"), alpha = 0.05)
summary(res1)
table(res1$padj < 0.05)

## Merge with normalized count data
resdata1 <- merge(as.data.frame(res1), as.data.frame(counts(dds.2, normalized=TRUE)), 
                 by="row.names", sort=FALSE)
names(resdata1)[1] <- "Gene"
res.ord1 <- resdata1[order(resdata1$padj),]
# tabla de resultados
```

Los resultados de la comparativa entre los datos de RNA-seq de la condición “ELI” y “NIT”, con un p-valor ajustado de 0.05 (padj), mostraron un total de 7258 genes diferencialmente expresados, frente a los 41470 genes del estudio (res1). Es estos 7258, 4605 estaban sobreexpresados (un 11% de los genes totales), con un valor outlier.

**Anotaciones**

Nuestra tabla de resultados hasta ahora solo contiene las ID de genes de Ensembl, pero los nombres de genes alternativos pueden ser más informativos para la interpretación. Los paquetes de anotación de Bioconductor ayudan a mapear varios esquemas de identificación entre sí. Cargamos el paquete AnnotationDbi y el paquete de anotación org.Hs.eg.db. Este es el paquete de anotación de organismos ("org") para el Homo sapiens ("Hs"), organizado como un paquete de base de datos AnnotationDbi ("db"), utilizando ID de genes de Entrez ("eg") como clave principal. 

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
library("AnnotationDbi")
library("org.Hs.eg.db")

columns(org.Hs.eg.db)

# Podemos usar la función mapIds para agregar columnas individuales a nuestra tabla de resultados. Proporcionamos los nombres de fila de nuestra tabla de resultados como una clave, y lo especificamos keytype=ENSEMBL. El columnargumento le dice a la función mapIds qué información queremos, y el multiVals argumento le dice a la función qué hacer si hay múltiples valores posibles para un solo valor de entrada. Aquí le pedimos que nos devuelva el primero que ocurre en la base de datos. Para agregar el símbolo del gen y la identificación de Entrez, llamamos a mapIds dos veces.

ens.str1 <- substr(rownames(res1), 1, 15)
res1$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str1,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res1$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str1,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

# Ahora los resultados tienen las ID de genes externas deseadas:

resOrdered1 <- res1[order(res1$pvalue),]
knitr::kable(head(resOrdered1))
```

Ahora los resultados tienen las ID de genes externas deseadas.

**Obtención de los genes up y down regulados**

Si consideramos que una fracción del 10% de falsos positivos es aceptable, podemos considerar todos los genes con un valor de p ajustado por debajo del 10% = 0.1 como significativos. Veamos cuantos de esos genes hay:

```{r echo=FALSE}
sum(res1$padj < 0.1, na.rm=TRUE)
```

*Subconjuntamos* la tabla de resultados a estos genes y luego los clasificamos por la estimación del log2change para obtener los genes significativos con la regulación descendente mínima:

```{r echo=FALSE}
resSig1 <- subset(res1, padj < 0.01)
knitr::kable(head(resSig1[ order(resSig1$log2FoldChange), ]))
```

y con la regulación up más elevada:

```{r echo=FALSE}
knitr::kable(head(resSig1[ order(resSig1$log2FoldChange, decreasing = TRUE), ]))
```

Los volcano-plots permiten visualizar si hay muchos o pocos genes con un gran fold-change y significativamente expresados o si este núumero es bajo. Estos gráaficos representan en abscisas los cambios de expresión en escala logarítmica y en ordenadas el "menos logaritmo" del p-valor [Figura 21].
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.cap='volcano plot que visualiza los rangos del p-value y foldchange entre los grupos ELI vs. NIT', fig.show = "hold", fig.height=4, fig.width=4}

# realizamos un basico volcano plot
with(resOrdered1, plot(log2FoldChange, -log10(pvalue), pch=20, xlim=c(-3,3)))

# anadimos los colores: azul si padj<0.01, rojo if log2FC>1 y padj<0.05)
with(subset(res1, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res1, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

**MA plot**

Los resultados del análisis de expresión diferencial bajo `DESeq2` se pueden visualizar mediante gráficos MA-Plot. Este tipo de gráficos se genera al representar la media de lecturas normalizadas de cada gen frente al logaritmo en base 2 del fold-change [Figura 22].
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.cap='MA plot con la matriz de comparacion entr los tres grupos de las medias normalizadas de cada gen respecto a log foldchange', fig.show = "hold", fig.height=4, fig.width=4}

## MA plot with "significant" genes labeled

maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=0.6, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=symbol, 
                                          cex=textcx, col=2))
  }
}
#png("diffexpr-maplot.png", 1500, 1000, pointsize=20)
maplot(resOrdered1, main="MA Plot")
```
\pagebreak

### SFI *vs* NIT

Creamos el objeto `res` para comparar ambos grupos y vemos el resumen y la tabla de los resultados,  fijando el umbral de la tasa de descubrimiento falso a un \alpha = 0.05, al igual que en el caso anterior:
```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}

res2 <- results(dds.2, contrast=c("condition","SFI","NIT"), alpha = 0.05)
summary(res2)
table(res2$padj < 0.05)

## Merge with normalized count data
resdata2 <- merge(as.data.frame(res2), as.data.frame(counts(dds.2, normalized=TRUE)), 
                 by="row.names", sort=FALSE)
names(resdata2)[1] <- "Gene"
res.ord2 <- resdata2[order(resdata2$padj),]
```

Los resultados de la comparativa entre los datos de RNA-seq de la condición “SFI” y “NIT”, con un p-valor ajustado de 0.05 (padj), mostraron un total de 303 genes diferencialmente expresados, frente a los 41470 genes del estudio. Es estos 303, 280 estaban sobreexpresados (un 0.68% de los genes totales), con un valor outlier.

**Anotaciones**

Incluimos las ID de genes externas a la matriz de resultados:

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}

ens.str2 <- substr(rownames(res2), 1, 15)
res2$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str2,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res2$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str2,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

# Ahora los resultados tienen las ID de genes externas deseadas:

resOrdered2 <- res2[order(res2$pvalue),]
knitr::kable(head(resOrdered2)[,3:8])
```

**Obtención de los genes up y down regulados**

Veamos los genes significativos si consideramos que una fracción del 10% de falsos positivos es aceptable:

```{r echo=FALSE}
sum(res2$padj < 0.1, na.rm=TRUE)
```

Los genes significativos con log2FoldChange mínimo:

```{r echo=FALSE}
resSig2 <- subset(res2, padj < 0.01)
knitr::kable(head(resSig2[ order(resSig2$log2FoldChange), ]))
```

y con la regulación up más fuerte:

```{r echo=FALSE}
knitr::kable(head(resSig2[ order(resSig2$log2FoldChange, decreasing = TRUE), ]))
```

Veamos el volcano plot correspondiente [Figura 23] y el MA plot [Figrua 24] de esta comparativa:
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.cap='volcano plot que visualiza los rangos del p-value y foldchange entre los grupos ELI vs. NIT', fig.show = "hold", fig.height=4, fig.width=4}

# realizamos un basico volcano plot
with(resOrdered2, plot(log2FoldChange, -log10(pvalue), pch=20, xlim=c(-3,3),label=symbol))

# anadimos los colores: azul si padj<0.01, rojo if log2FC>1 y padj<0.05)
with(subset(res2, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res2, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

```{r echo=FALSE, message=FALSE, warning=FALSE,fig.cap='MA plot con la matriz de comparacion entr los tres grupos de las medias normalizadas de cada gen respecto a log foldchange', fig.show = "hold", fig.height=4, fig.width=4}

## MA plot with "significant" genes labeled

maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=0.6, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=symbol, 
                                          cex=textcx, col=2))
  }
}
#png("diffexpr-maplot1.png", 1500, 1000, pointsize=20)
maplot(resOrdered2, main="MA Plot")
```
\pagebreak

### SFI *vs* ELI

Vemos la tabla de resultados con aquellos genes que tienen un menor p-value y por tanto, pueden que esten diferencialmente expresados. Fijamos el umbral de la tasa de descubrimiento falso a un \alpha = 0.05, al igual que en el caso anterior. Como hemos visto esta tabla proporciona los valores básicos a través de muestras, log2 fold changes, errores estándar, test estadísticos, valores p y valores p ajustados:

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}
res3 <- results(dds.2, contrast=c("condition","SFI","ELI"), alpha = 0.05)
summary(res3)
table(res3$padj < 0.05)

## Merge with normalized count data
resdata3 <- merge(as.data.frame(res3), as.data.frame(counts(dds.2, normalized=TRUE)), 
                 by="row.names", sort=FALSE)
names(resdata3)[1] <- "Gene"
res.ord3 <- resdata3[order(resdata3$padj),]
# tabla de resultados
```

Los resultados de la comparativa entre los datos de RNA-seq de la condición “SFI” y “ELI”, con un p-valor ajustado de 0.05 (padj), mostraron un total de 7003 genes diferencialmente expresados, frente a los 41470 genes del estudio. Es estos 7003, 2884 estaban sobreexpresados (un 7% de los genes totales), con un valor outlier.

**Anotaciones**

Incluimos las ID de genes externas a la matriz de resultados:

```{r echo=FALSE, message=FALSE, warning=FALSE, tidy=TRUE}

ens.str3 <- substr(rownames(res3), 1, 15)
res3$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str3,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res3$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str3,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

resOrdered3 <- res3[order(res3$pvalue),]
knitr::kable(head(resOrdered3))
```

**Obtención de los genes up y down regulados**

Veamos los genes significativos si consideramos que una fracción del 10% de falsos positivos es aceptable:

```{r echo=FALSE}
sum(res3$padj < 0.1, na.rm=TRUE)
```

Los genes significativos de la tabla de resultados clasificados por la estimación del log2change con la regulación mínima:

```{r echo=FALSE}
resSig3 <- subset(res3, padj < 0.01)
knitr::kable(head(resSig3[ order(resSig3$log2FoldChange), ]))
```

y con log2FoldChange up máximo:

```{r echo=FALSE}
knitr::kable(head(resSig3[ order(resSig3$log2FoldChange, decreasing = TRUE), ]))
```

Veamos el volcano plot correspondiente [Figura 25] y el MA plot [Figrua 26] de esta comparativa:
```{r echo=FALSE, fig.show = "hold", fig.height=4, fig.width=4, message=FALSE, warning=FALSE, fig.cap='volcano plot que visualiza los rangos del p-value y foldchange entre los grupos ELI vs. NIT'}

# realizamos un basico volcano plot
with(resOrdered3, plot(log2FoldChange, -log10(pvalue), pch=20, xlim=c(-3,3)))

# anadimos los colores: azul si padj<0.01, rojo if log2FC>1 y padj<0.05)
with(subset(res3, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res3, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

```{r echo=FALSE, fig.show = "hold", fig.height=4, fig.width=4, message=FALSE, warning=FALSE, fig.cap='MA plot con la matriz de comparacion entr los tres grupos de las medias normalizadas de cada gen respecto a log foldchange'}

## MA plot with "significant" genes labeled

maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=0.6, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=symbol, 
                                          cex=textcx, col=2))
  }
}
#png("diffexpr-maplot2.png", 1500, 1000, pointsize=20)
maplot(resOrdered3, main="MA Plot")

```
\pagebreak

## Gráfico de diferencia de medias

Una gráfica de diferencia de medias (MA-PLOT) permite visualizar la distribución de los coeficientes estimados en el modelo, como pueden ser las comparaciones entre genes. En el eje y se sitúa el valor del LFC, mientras que en el eje x se sitúan las medias de los counts normalizados. En DESeq2, la función plotMA muestra los cambios de pliegue log2 atribuibles a una variable dada sobre la media de los recuentos normalizados para todas las muestras en el `DESeqDataSet` . Los puntos serán de color azul si el valor p ajustado es menor que 0.1. Los puntos que se caen de la ventana se trazan como triángulos abiertos que apuntan hacia arriba o hacia abajo [Figuras 27, 28, 29].

```{r echo=FALSE, fig.height=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Gráfico de la diferencia de medias en ELI vs. NIT', fig.show = "hold"}

DESeq2::plotMA(res1, main="", ylim=c(-2,2))
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```


```{r echo=FALSE, fig.height=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Gráfico de la diferencia de medias en SFI vs. NIT', fig.show = "hold"}
DESeq2::plotMA(res2, main="", ylim=c(-2,2))
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```


```{r echo=FALSE, fig.height=4, message=FALSE, warning=FALSE, tidy=TRUE, fig.cap='Gráfico de la diferencia de medias en SFI vs. ELI', fig.show = "hold"}
DESeq2::plotMA(res3, main="", ylim=c(-2,2))
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```

\pagebreak

# Resultados

Tabla 1: Resutados edgeR

| Datos | **ELI vs. NIT** |  **SFI vs. NIT** |  **SFI vs. ELI** |
| ------------------| ------------------| ------------------| ------------------|
| *significativos* | 15 % | 0.6 % | 15 % |
| *no significativos* | 33996 | 39743 | 34356 |
| *sobreexpresados* | 2042 | 221 | 2282 |
| *infraeexpresados* | 3933 | 7 | 3333 |

Tabla 2: Resutados DESeq2

| Datos | **ELI vs. NIT** |  **SFI vs. NIT** |  **SFI vs. ELI** |
| ------------------| ------------------| ------------------| ------------------|
| *significativos* | 17.4 % | 0.7 % | 17 % |
| *no significativos* | 242564 | 26693  | 23211 |
| *sobreexpresados* | 4605 | 280 | 2284 |
| *infraeexpresados* | 2653 | 23 | 4119 |

A pesar que número de genes empleado en cada estudio, no es el mismo, ya que hemos empleado distinto metodo de filtrado y eliminacion de genes poco significativos (sólo se diferencian en 1500 genes), los resultados obtenidos respecto a al porcentaje de genes DE (diferencialmente expresados) es muy similar en ambos casos.

Podemos decir por tanto, que hay 15 % de genes DE entre los grupos ELI vs. NIT y ELI vs. SFI, mientras que en la tercera comparación el percentaje de genes DE es menor al 1%, siendo por tanto el grupo ELI el que se diferencia claramente de los otros dos grupos.

Ya que ambos paquetes poseen algunas variaciones en sus análisis estadísticos, los genes concretos diferencialmente expresados en cada comparación no coinciden exactamente en los dos paquetes, pero algunos genes si que aparecen en ambos análisis, reafirmando por tanto, su definición como genes DE.

Ya que según los resultados en porcentajes y números de las dos tablas anteriroes, el paquete `edgeR` parece ser más restrictivo, incluyo aqui los genes diferencialmente expresados que identifica:

```{r echo=FALSE}
(top)[1:10,-1]
```


```{r}
(top.2)[1:10,-1]
```

# Discusión

El análisis de expresión génica diferencial llevado a cabo con conjuntos de datos reales permitió
identificar, en cada estudio, los genes cuya expresión era significativamente diferente entre los grupos de la comparación. No se solicitaba relizar el estudio con ambos paquetes pero ha sido útil encontrar las importantes similitudes, diferencias y limitaciones de ambos con los mismos datos y comprobar que los resultados han sido muy similares.

Aunque una parte de los genes DE fueron comunes a los dos paquetes de Bioconductor, el número de genes seleccionados por cada uno de ellos difirió, por lo que me he tenido que decantar por uno de ellos al tener que presentar los resultados. Aunque con el paquete DESeq2, se puede hacer el estudio con menos pasos, parece que edgeR es más restrictivo en la selección de los genes DE. Supongo que dependerá del tipo de estudio realizado, que se deberá emplear mejor uno u otro.

Por otro lado, he encontrado ciertas dificultades al incorporar los datos de las anotaciones a la matriz de resultados de ambos paquetes, ya que algunos genes no se identificaban como tales y el valor incorporado era NA. Habria que profundzar si la anotación empleada es la adecuada, pero he probado diferentes y obtenía los mismos resultados. Sin embargo, este paso no es fundamental para la realización del análisis, por lo que el número y tipo de genes DE no se vería modificado.

Por último hacer referencia al paso de eliminar los genes con pocos o ningún valor en la matriz de conteos. En este caso, podríamos haber optado por no realizarlo ya que el número de muestras no era muy elevado (30). Sin embargo, es un paso importante a realizar para la visualización y entendimiento de los gráficos, ya que aportan mucho ruido al análisis.

# Apéndice: Código R empleado

## Datos

Para facilitar la reproducibilidad del informe, se han incluido varios parámetros en el encabezado `YAML` del documento cuyos valores se pueden establecer cuando se procesa el informe. Se ha incluido tanto la carpeta donde se ecuentran los datos como los nombres de los archivos y la ruta de acceso, de esta forma podemos leer los datos con el siguiente código:


```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
library(readr)
library(knitr)

### Lectura de los datos de contajes
counts <- read_delim(file=file.path(params$folder.data,params$file1),";",
                      col_names = TRUE)

counts[] <- lapply(counts, function(x) { 
    if(is.factor(x)) as.numeric(as.character(x)) else x 
}) 
sapply(counts, class) 

# El nombre de las filas pertenece a las claves de tipo "ENSEMBL", conteniendo un punto y la 
# versión de éste. Eliminamos la version y el punto para que posteriormente podamos emplear 
# la AnnotationDBI para mapear mediante DESeq, si es necesario.

library(stringr)

counts[,1] = str_replace_all(counts$X1, "[.].{0,2}$", "")

# pasar a matriz de caracteres a numericos con el nombre de cada fila y columna

conteos <- data.matrix(counts[,-1])

dimnames(conteos) <- counts[,1]
colnames(conteos) <- colnames(counts[,-1])

length(complete.cases(conteos)) # comprobamos que el dataset está completo

### Lectura de los datos de las muestras "targets"
targets <- read_delim(file=file.path(params$folder.data,params$file2),",",
                      col_names = TRUE)
length(complete.cases(targets))

utils::head(counts)[,1:3]
utils::head(targets)[,1:5]

### Script para la selección de las 30 muestras

set.seed(12378)
n <- 10
library(dplyr)

#Grupo NIT
muestra_nit <- targets %>%
  filter(Group=="NIT" & molecular_data_type == "RNA Seq (NGS)") %>%
  sample_n(size=n,replace=FALSE)

#Grupo ELI
muestra_eli <- targets %>%
  filter(Group=="ELI") %>%
  sample_n(size=n,replace=FALSE)

#Grupo SFI
muestra_sfi <- targets %>%
  filter(Group=="SFI" & molecular_data_type == "RNA Seq (NGS)") %>%
  sample_n(size=n,replace=FALSE)

#Unir los grupos en un data frame
subset <- rbind(muestra_nit,muestra_eli, muestra_sfi)
utils::head(subset)[,1:5]
#write.table(subset, "./datos/subset.csv") #Guardamos la tabla en nuestra ruta de trabajo

### Crear la matriz count con las dimensiones del subset
library(dplyr)
conteos.data.frame <- as.data.frame(conteos)
counts.subset<- dplyr::select(conteos.data.frame, contains(subset$Sample_Name))

```

## Análisis con el paquete edgeR

### Preparación de los datos: Anotacion, filtrado y normalización

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}

# Creamos el objeto con la clase DGEList a partir de la matriz de conteos
dge <- DGEList(counts=counts.subset, group=subset$Group, genes = counts$X1)
dim(dge) # comprobamos se mantienen las dimensiones de la matriz:

## Anotación

## Cargamos el paquete AnnotationDbi y el paquete de anotación org.Hs.eg.db.
## Podemos usar la función mapIds para agregar columnas individuales a nuestra tabla de resultados. Proporcionamos los nombres de fila de nuestra tabla de resultados como una clave, y lo especificamos keytype=ENSEMBL.

library("AnnotationDbi")
library("org.Hs.eg.db")
ens.str <- substr(rownames(dge), 1, 15)
dge$genes$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")

dge$genes$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

head(dge$genes) # los resultados tienen las ID de genes externas

## Filtrado y transformación

# La transformación que se llevó a cabo fue la conversión de las lecturas a CPM (conteos por millón). En este caso, ya que los grupos son pequeños, no más de diez muestras cada grupo, se mantendrán los genes que logran al menos 0.3 cpm de tres en el filtrado.

# Paso de los datos a CPM conteos por millón, con la funcion cpm del paquete edgeR.
library(edgeR)
select.genes <- rowSums(cpm(dge)>0.01) >= 3
dge <- dge[select.genes,] # Nuevo objeto de estudio, ya filtrado.
dim(dge) # Vemos la nueva dimensión de nuestra matriz de trabajo

# Vemos el tamaño de las librerias antes y después del filtrado
  
dge$samples$lib.size # antes del filtrado

# Después del filtrado:
dge$samples$lib.size <- colSums(dge$counts)
dge$samples$lib.size # Nuevo tamaño de la librería

## Normalización

# Gráfico de las muestras sin normalizar

# log2 conteos por millón
logcounts <- cpm(dge,log=TRUE)
# boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=1, cex.axis = 0.6)
# Añadimos una linea azul que se corresponde con la media logCPM
abline(h=median(logcounts),col="blue")

## La normalización por el método TMM s
dge.norm <- calcNormFactors(dge)
head(dge.norm$samples)

# Gráfico de las muestras sin normalizadas

# log2 conteos por millón
logcounts1 <- cpm(dge.norm,log=TRUE)
# boxplots
boxplot(logcounts1, xlab="", ylab="Log2 counts per million",las=1, cex.axis = 0.6)
# Linea azul con la media logCPM
abline(h=median(logcounts1),col="blue")
```

### Exploración de los datos

```{r eval=FALSE, fig.height=5, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
# El gráfico MDS 
grupo <- as.factor(as.character(subset$Group))
col.status <- c("blue","red","dark green")[grupo]
plotMDS(dge.norm$counts, labels = grupo, col=col.status)
legend("bottomright",fill=c("blue","red","dark green"),legend=levels(grupo))

# Grafico MD
plotMD(dge.norm, column=1)
abline(h=0, col="red", lty=2, lwd=2)

# Loop para representar de forma gráfica los plotMD de cada una de las mestras

par(mfrow=c(3,2))
# Create the loop.vector (all the columns)
loop.vector <- 1:30

for (i in loop.vector) { # Loop over loop.vector

    # Plot histogram of x
  plotMD(dge.norm, column=i)
  abline(h=0, col="red", lty=2, lwd=2)
}

# Heatmap
cimColor <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)[255:1]
heatmap(cor(logcounts1), col=cimColor)
```

### Estimación de la dispersión

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
disp <- estimateCommonDisp(dge.norm,verbose=TRUE)

disp.all <- estimateDisp(dge.norm, robust=TRUE)

# Al calcular la dispersión común añadiremos como atributo en la función 
# verbose = TRUE para que muestre los valores del coeficiente de variación 
# biológico (BCV) y la dispersión común.
 
disp.estim <- estimateTagwiseDisp(disp)

# Gráfico BCV que muestra la dispersion entre los dstintos genes
plotBCV(disp.all)

# métodos de cuasi-verosimilitud (QL) 
fit <- glmQLFit(disp.all, robust=TRUE)
head(fit$coefficients)

# Gráfico de la dispersión cuasi-verosimilitud de genes respecto la media log2 en recuentos por millón
plotQLDisp(fit)
summary(fit$df.prior)
```

### Análisis de expresión diferencial
#### Comparación entre los grupos ELI y NIT

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
et <- exactTest(disp.estim, pair = c("ELI","NIT"))
top <- topTags(et, n=39971)
head(top)[,-1] # los transcritos más diferencialmente expresados

detags.com <- rownames(topTags(et)$table)
disp$counts[detags.com, 1:4]

# genes que se consideran diferencialmente expresados, según posean un FDR menor a 0.5:
table(top$table$FDR <0.5)
table(top$table$FDR <0.05)/nrow(top$table)

# Histograma FDR (ELI vs. NIT)
hist(top$table$FDR, breaks=100, xlab="FDR", main="")
abline(v=0.05, col="red", lwd=3)

# clasificación de los genes como no significativos en FDR <0.05:
de <- decideTestsDGE(et)
summary(de)

# cambios log-fold-tagwise contra log-cpm (análogo a un gráfico MA para datos de microarrays)
detags <- rownames(dge)[as.logical(de)]
plotSmear(et, de.tags=detags)
abline(h=c(-1,1), col="blue")
```

#### Comparación entre los grupos SFI y NIT

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
et.1 <- exactTest(disp.estim, pair = c("NIT", "SFI")) # con el comando `pair` indicamos 
# la comparación que queremos realizar
top.1 <- topTags(et.1, n=39971)
head(top.1)[,-1]

# genes que se consideran diferencialmente expresados, según posean un FDR menor a 0.5:
table(top.1$table$FDR <0.5)
table(top.1$table$FDR <0.05)/nrow(top.1$table)

# Histograma FDR (SFI vs. NIT)
hist(top.1$table$FDR, breaks=100, xlab="FDR", main="")
abline(v=0.05, col="red", lwd=3)

# clasificación de los genes como no significativos en FDR <0.05:
de.1 <- decideTestsDGE(et.1)
summary(de.1)

# cambios log-fold-tagwise contra log-cpm
detags.1 <- rownames(dge)[as.logical(de.1)]
plotSmear(et.1, de.tags=detags.1)
abline(h=c(-1,1), col="blue")
```

#### Comparación entre los grupos SFI y ELI

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
et.2 <- exactTest(disp.estim, pair = c("ELI", "SFI")) # con el comando `pair` indicamos 
# la comparación que queremos realizar
top.2 <- topTags(et.2, n=39971)
head(top.2)[,-1]

# genes que se consideran diferencialmente expresados, según posean un FDR menor a 0.5:
table(top.2$table$FDR <0.5)
table(top.2$table$FDR <0.05)/nrow(top.2$table)

# Histograma FDR (SFI vs. NIT)
hist(top.2$table$FDR, breaks=100, xlab="FDR", main="")
abline(v=0.05, col="red", lwd=3)

# clasificación de los genes como no significativos en FDR <0.05:
de.2 <- decideTestsDGE(et.2)
summary(de.2)

# cambios log-fold-tagwise contra log-cpm
detags.2 <- rownames(dge)[as.logical(de.2)]
plotSmear(et.2, de.tags=detags.2)
abline(h=c(-1,1), col="blue")
```

## Análisis con DESeq2
### DESeq Dataset

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
library(DESeq2) # creamos el objeto DESEQDataSet

condition <- factor(subset$Group)
coldata <- data.frame(row.names=colnames(counts.subset), condition)

dds <- DESeqDataSetFromMatrix(countData=counts.subset, 
                              colData=coldata, 
                              design=~condition)
dds

dds.1 <- DESeq(dds) # Run the DESeq pipeline
dds.1

# Plot dispersions
#png("qc-dispersions.png", 1000, 1000, pointsize=20) # Guardar el gráfico
plotDispEsts(dds.1)
```

### Análisis exploratorio y visualizacion
#### Filtrado de datos

```{r eval=FALSE, include=TRUE}
# regla de filtrado más restrictiva
keep1 <- rowSums(counts(dds.1) >= 5) >= 2
dds.3 <- dds.1[keep1,]
nrow(dds.3)

nrow(dds.1) # regla de filtrado empleada
keep <- rowSums(counts(dds.1)) > 2
dds.2 <- dds.1[keep,]
nrow(dds.2)
```

#### Transformación de los datos para su visualización

```{r eval=FALSE, fig.width=6, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
# Regularized log transformation
# rld <- rlogTransformation(dds.2)
par(mfrow=c(1,2))
hist(assay(rld), main = "Hist transf con rlog")

vsdata <- vst(dds.2, blind=FALSE)
hist(assay(vsdata), main = "Hist transf con vst")

#Efecto visual de amabas transformaciones, rlog y vst
par(mfrow=c(1,3))
plot(assay(dds.2))
plot(assay(rld))
plot(assay(vsdata))
```

#### Distancia entre las muestras

```{r eval=FALSE, fig.height=6.5, fig.width=7, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
# Heatmap que representa las distancias entre las distintas muestras
# Definimos los colores para el gráfico empleando RColorBrewer
library(RColorBrewer)
mycols <- brewer.pal(8, "Dark2")[1:length(unique(condition))]

# heatmap de los valores transformados de las muestras
sampleDists <- as.matrix(dist(t(assay(rld))))
library(gplots)
#png("qc-heatmap-samples.png", w=1000, h=1000, pointsize=20)
heatmap.2(as.matrix(sampleDists), key=F, trace="none",col=colorpanel(100, "black", 
                                                                     "white"),
          ColSideColors=mycols[condition], RowSideColors=mycols[condition],margin=c(10, 10),
          main="Sample Distance Matrix")

# las relaciones entre los genes más variables dentro de las muestras. Usando en este caso la transformación vsd, seleccionemos los 10 genes con la mayor varianza entre las muestras:

library("genefilter")
topVarGenes <- head(order(rowVars(assay(vsdata)), decreasing = TRUE), 10)

mat  <- assay(vsdata)[topVarGenes, ]
mat  <- mat - rowMeans(mat)
anno <- as.data.frame(colData(vsdata)[, c("condition", "sizeFactor")])
pheatmap(mat, annotation_col = anno)
```

#### Análisis de componentes principales

```{r eval=FALSE, fig.height=4, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
# Análisis de componentes principales entre las muestras transformadas de forma logaritmica
DESeq2::plotPCA(rld, intgroup="condition")

# la función vst realizará una transformación estabilizadora de varianza
plotPCA(vsdata, intgroup="condition") #usamos DESEQ2 plotPCA fxn

# incluimos los nombres de las muestras en el gráfico:

rld_pca <- function (rld, intgroup = "condition", ntop = 500, colors=NULL, 
                     legendpos="bottomleft", main="PCA Biplot", textcx=0.55, ...) {
  require(genefilter)
  require(calibrate)
  library(calibrate)
  require(RColorBrewer)
  rv = rowVars(assay(rld))
  select = order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  pca = prcomp(t(assay(rld)[select, ]))
  fac = factor(apply(as.data.frame(colData(rld)[, intgroup, drop = FALSE]), 1, paste,
               collapse = " : "))
  if (is.null(colors)) {
    if (nlevels(fac) >= 3) {
      colors = brewer.pal(nlevels(fac), "Paired")
    }   else {
      colors = c("black", "red")
    }
  }
  pc1var <- round(summary(pca)$importance[2,1]*100, digits=1)
  pc2var <- round(summary(pca)$importance[2,2]*100, digits=1)
  pc1lab <- paste0("PC1 (",as.character(pc1var),"%)")
  pc2lab <- paste0("PC1 (",as.character(pc2var),"%)")
  plot(PC2~PC1, data=as.data.frame(pca$x), bg=colors[fac], pch=21, xlab=pc1lab, ylab=pc2lab, main=main, ...)
  with(as.data.frame(pca$x), textxy(PC1, PC2, labs=rownames(as.data.frame(pca$x)), 
                                    cex=textcx))
  legend(legendpos, legend=levels(fac), col=colors, pch=20)
}
#png("qc-pca.png", 1000, 1000, pointsize=20)
rld_pca(rld, colors=mycols, intgroup="condition", xlim=c(-75, 35))
```

### plotCounts

```{r eval=FALSE, fig.height=4.5, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
par(mfrow=c(2,3))

plotCounts(dds.2, gene="ENSG00000168615", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000110680", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000236935", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000226423", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000177721", intgroup="condition")
plotCounts(dds.2, gene="ENSG00000264940", intgroup="condition")
```

### Análisis de expresión diferencial

#### ELI *vs* NIT

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}

res1 <- results(dds.2, contrast=c("condition","ELI","NIT"), alpha = 0.05)
summary(res1)
table(res1$padj < 0.05)

## creamos data frame junto con los datos normalizados
resdata1 <- merge(as.data.frame(res1), as.data.frame(counts(dds.2, normalized=TRUE)),
            by="row.names", sort=FALSE)
names(resdata1)[1] <- "Gene"
res.ord1 <- resdata1[order(resdata1$padj),]
# tabla de resultados

## Anotaciones

columns(org.Hs.eg.db)

# Podemos usar la función mapIds para agregar columnas individuales a nuestra tabla de resultados. Proporcionamos los nombres de fila de nuestra tabla de resultados como una clave, y lo especificamos keytype=ENSEMBL. El columnargumento le dice a la función mapIds qué información queremos, y el multiVals argumento le dice a la función qué hacer si hay múltiples valores posibles para un solo valor de entrada. Aquí le pedimos que nos devuelva el primero que ocurre en la base de datos. Para agregar el símbolo del gen y la identificación de Entrez, llamamos a mapIds dos veces.

ens.str1 <- substr(rownames(res1), 1, 15)
res1$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str1,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res1$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str1,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

# Ahora los resultados tienen las ID de genes externas deseadas:

resOrdered1 <- res1[order(res1$pvalue),]
head(resOrdered1)

## Obtención de los genes up y down regulados

# 10% de falsos positivos es aceptable
sum(res1$padj < 0.1, na.rm=TRUE)

# genes significativos con la regulación descendente más fuerte:
resSig1 <- subset(res1, padj < 0.01)
head(resSig1[ order(resSig1$log2FoldChange), ])

# y con la regulación up más fuerte:
head(resSig1[ order(resSig1$log2FoldChange, decreasing = TRUE), ])

# realizamos un basico volcano plot
with(resOrdered1, plot(log2FoldChange, -log10(pvalue), pch=20, xlim=c(-3,3)))

# anadimos los colores: azul si padj<0.01, rojo if log2FC>1 y padj<0.05)
with(subset(res1, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res1, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))

## MA plot
## MA plot with "significant" genes labeled
maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=0.6, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=symbol, 
              cex=textcx, col=2))
  }
}
#png("diffexpr-maplot.png", 1500, 1000, pointsize=20)
maplot(resOrdered1, main="MA Plot")
```

#### SFI *vs* NIT

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}

res2 <- results(dds.2, contrast=c("condition","SFI","NIT"), alpha = 0.05)
summary(res2)
table(res2$padj < 0.05)

## creamos data frame junto con los datos normalizados
resdata2 <- merge(as.data.frame(res2), as.data.frame(counts(dds.2, normalized=TRUE)), 
          by="row.names", sort=FALSE)
names(resdata2)[1] <- "Gene"
res.ord2 <- resdata2[order(resdata2$padj),]

## Anotacion
ens.str2 <- substr(rownames(res2), 1, 15)
res2$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str2,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res2$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str2,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

# Ahora los resultados tienen las ID de genes externas deseadas:

resOrdered2 <- res2[order(res2$pvalue),]
head(resOrdered2)[,3:8]

## Obtención de los genes up y down regulados

sum(res2$padj < 0.1, na.rm=TRUE)

# genes significativos con la regulación descendente más fuerte:
resSig2 <- subset(res2, padj < 0.01)
head(resSig2[ order(resSig2$log2FoldChange), ])

# con la regulación up más fuerte:

# realizamos un básico volcano plot
with(resOrdered2, plot(log2FoldChange, -log10(pvalue), pch=20, xlim=c(-3,3),label=symbol))

# anadimos los colores: azul si padj<0.01, rojo if log2FC>1 y padj<0.05)
with(subset(res2, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res2, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))

## MA plot
maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=0.6, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, 
                                    cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=symbol,
                                    cex=textcx, col=2))
  }
}
#png("diffexpr-maplot1.png", 1500, 1000, pointsize=20)
maplot(resOrdered2, main="MA Plot")
```

#### SFI *vs* ELI

```{r eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
res3 <- results(dds.2, contrast=c("condition","SFI","ELI"), alpha = 0.05)
summary(res3)
table(res3$padj < 0.05)

## creamos data frame junto con los datos normalizados
resdata3 <- merge(as.data.frame(res3), as.data.frame(counts(dds.2, normalized=TRUE)),
            by="row.names", sort=FALSE)
names(resdata3)[1] <- "Gene"
res.ord3 <- resdata3[order(resdata3$padj),]
# tabla de resultados

## Anotaciones
### Incluimos las ID de genes externas a la matriz de resultados:
ens.str3 <- substr(rownames(res3), 1, 15)
res3$symbol <- mapIds(org.Hs.eg.db,
                     keys=ens.str3,
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
res3$entrez <- mapIds(org.Hs.eg.db,
                     keys=ens.str3,
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

resOrdered3 <- res3[order(res3$pvalue),]
head(resOrdered3)

## Obtención de los genes up y down regulados**
sum(res3$padj < 0.1, na.rm=TRUE)

resSig3 <- subset(res3, padj < 0.01)
head(resSig3[ order(resSig3$log2FoldChange), ])

## y con la regulación up más fuerte:
head(resSig3[ order(resSig3$log2FoldChange, decreasing = TRUE), ])

# realizamos un basico volcano plot
with(resOrdered3, plot(log2FoldChange, -log10(pvalue), pch=20, xlim=c(-3,3)))

# anadimos los colores: azul si padj<0.01, rojo if log2FC>1 y padj<0.05)
with(subset(res3, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res3, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))

## MA plot
maplot <- function (res, thresh=0.05, labelsig=TRUE, textcx=0.6, ...) {
  with(res, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, 
                                        cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res, padj<thresh), textxy(baseMean, log2FoldChange, labs=symbol, 
                                        cex=textcx, col=2))
  }
}
#png("diffexpr-maplot2.png", 1500, 1000, pointsize=20)
maplot(resOrdered3, main="MA Plot")

```

### Gráfico de diferencia de medias

```{r eval=FALSE, fig.height=4, message=FALSE, warning=FALSE, include=TRUE, tidy=TRUE}
DESeq2::plotMA(res1, main="MA-plot DESeq2 ELI vs. NIT", ylim=c(-2,2))
abline(h=c(-1,1), col="dodgerblue", lwd=2)
DESeq2::plotMA(res2, main="MA-plot DESeq2 SFI vs. NIT", ylim=c(-2,2))
abline(h=c(-1,1), col="dodgerblue", lwd=2)
DESeq2::plotMA(res3, main="MA-plot DESeq2 SFI vs. ELI", ylim=c(-2,2))
abline(h=c(-1,1), col="dodgerblue", lwd=2)
```

### Resultados

```{r eval=FALSE, include=TRUE}
(top)[1:10,-1]

(top.2)[1:10,-1]
```

# Bibliografía
